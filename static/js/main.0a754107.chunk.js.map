{"version":3,"sources":["components/Cell.js","components/GameScreen.js","components/Buttons.js","components/Rules.js","util/gridCreation.js","App.js","index.js"],"names":["Cell","changeCell","cellItem","alive","x","y","className","onClick","GameScreen","grid","map","row","i","key","Buttons","generations","speed","setSpeed","setPlay","play","updateGrid","clearGrid","nextGen","useState","gridSize","setGridsize","disabled","type","min","max","value","id","onChange","e","target","onKeyPress","onTouchEnd","htmlFor","Rules","props","gridCreation","j","col","push","nextGeneration","copyGrid","newGrid","length","liveNeighbours","App","setGridSize","setGrid","setGeneration","useEffect","setTimeout","val","newState","href","rel","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0a754107.chunk.js","sourcesContent":["import React from \"react\"\r\n\r\n\r\nconst Cell = ({changeCell, cellItem}) => {\r\n\r\n    const  {alive, x, y} = cellItem;\r\n\r\n\r\n    return (\r\n        <div className={`${alive ? \"alive\": ''} cell`} onClick={()=> changeCell({x,y})}>\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\n\r\nexport default Cell","import React from 'react';\r\nimport Cell from \"./Cell\";\r\n\r\nfunction GameScreen({grid,changeCell}) {\r\n\r\n    return (\r\n\r\n        <div className=\"game-screen\">\r\n            <div className=\"grid\">\r\n                {   \r\n                    grid.map((row,i) => {\r\n                        return (<div className=\"row\" key={i}>\r\n                            {row.map(cellItem => <Cell key={cellItem.x+cellItem.y} cellItem={cellItem} changeCell={changeCell}/>)}\r\n                        </div>)\r\n                    })\r\n                }\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nexport default GameScreen","import React, {useState} from 'react';\r\n\r\nfunction Buttons({generations, speed, setSpeed, setPlay, play, updateGrid, clearGrid, nextGen}) {\r\n    \r\n    const [gridSize, setGridsize] = useState(25)\r\n\r\n    const updateGridSize = (e) => {\r\n        setGridsize(e.target.value)\r\n    }\r\n\r\n    const onPlayGen = () => {\r\n        setPlay(!play)\r\n    }\r\n\r\n    return (\r\n\r\n        <div className=\"buttons\">\r\n\r\n            <p>Generations: {generations}</p>\r\n            <div className=\"actions-container\">\r\n                <button className=\"clear\" onClick={clearGrid}>Clear</button>\r\n\r\n                <button className=\"play\" onClick={onPlayGen}>{play ? 'Pause': 'Play'}</button>\r\n                \r\n                <button className=\"next-gen\" disabled={play} onClick={nextGen}>Next Generation</button>\r\n\r\n            </div>\r\n\r\n            <div className=\"speed-container\">\r\n                <button onClick={()=> setSpeed(speed*2)}>Slower</button>\r\n                <p>Speed: {speed}ms</p>\r\n                <button onClick={()=> setSpeed(speed/2)}>Faster</button>\r\n            </div>\r\n\r\n            <div className=\"grid-container\">\r\n                <input \r\n                    disabled={play} \r\n                    type=\"range\" \r\n                    min=\"4\" \r\n                    max=\"50\" \r\n                    value={gridSize} \r\n                    className=\"slider\" \r\n                    id=\"speedRange\" \r\n                    onChange={updateGridSize} \r\n                    onClick={()=> updateGrid(gridSize)} \r\n                    onKeyPress={(e) => { \r\n                        if (e.key === \"Enter\"){\r\n                            updateGrid(gridSize)\r\n                        }\r\n                    }} \r\n                    onTouchEnd={() => updateGrid(gridSize)}\r\n                />\r\n                <label className=\"grid-size\" htmlFor=\"speedRange\">{gridSize} x {gridSize}</label>\r\n\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nexport default Buttons","import React from \"react\";\r\n\r\n\r\nfunction Rules(props) {\r\n    return (\r\n        <div className=\"rules\">\r\n            <section>\r\n                <h2>Rules</h2>\r\n                <p>The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:</p>\r\n                <ol>\r\n                    <li>Any live cell with fewer than two live neighbours dies, as if by underpopulation.</li> \r\n                    <li>Any live cell with two or three live neighbours lives on to the next generation.</li>\r\n                    <li>Any live cell with more than three live neighbours dies, as if by overpopulation.</li>\r\n                    <li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li>\r\n                </ol>\r\n                <p>These rules, which compare the behavior of the automaton to real life, can be condensed into the following:</p>\r\n                <ol>\r\n                    <li>Any live cell with two or three live neighbours survives.</li>\r\n                    <li>Any dead cell with three live neighbours becomes a live cell.</li>\r\n                    <li>All other live cells die in the next generation. Similarly, all other dead cells stay dead.</li>\r\n                </ol>\r\n                <p>The initial pattern constitutes the seed of the system. The first generation is created by applying the above rules simultaneously to every cell in the seed; births and deaths occur simultaneously, and the discrete moment at which this happens is sometimes called a tick. Each generation is a pure function of the preceding one. The rules continue to be applied repeatedly to create further generations.</p>\r\n            </section>\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nexport default Rules","function gridCreation(gridSize) {\r\n\r\n    const grid = []\r\n      \r\n        for(let i = 0; i < gridSize; i++){\r\n    \r\n            const row = []\r\n            for(let j = 0; j < gridSize; j++){\r\n                \r\n                const col = {'alive': false, 'x' : j,'y' : i}\r\n                row.push(col)\r\n    \r\n            }\r\n    \r\n            grid.push(row)\r\n    \r\n        }\r\n\r\n      return grid\r\n}  \r\n\r\nfunction nextGeneration(grid) {\r\n    \r\n    const copyGrid = [...grid]\r\n    // console.log(copyGrid)\r\n\r\n    const newGrid = []\r\n\r\n    for(let i = 0; i < copyGrid.length; i++){\r\n    \r\n        const row = []\r\n        for(let j = 0; j < copyGrid[i].length; j++){\r\n            \r\n            // const col = {'alive': false, 'x' : j,'y' : i}\r\n            // check the values here and update the cell\r\n            // we only update this cell based on other cells around it\r\n\r\n            \r\n            const col = {'alive': false, 'x' : j,'y' : i}\r\n            \r\n            \r\n            // if there is more than 4 neighbours continue to next j since cell will\r\n            // dead\r\n            // adding up live neighbours\r\n            var liveNeighbours = 0\r\n            // top\r\n            if (i - 1 >= 0 && j-1 >= 0 && copyGrid[i-1][j-1].alive){\r\n\r\n                liveNeighbours += 1\r\n            }\r\n            if (i - 1 >= 0 && copyGrid[i-1][j].alive){\r\n                liveNeighbours += 1\r\n            }\r\n            if ( i - 1 >= 0 && j+1 < copyGrid[i].length && copyGrid[i-1][j+1].alive){\r\n                liveNeighbours += 1\r\n            }\r\n\r\n            // center\r\n            if (j - 1 >= 0&& copyGrid[i][j-1].alive){\r\n                liveNeighbours += 1\r\n            }\r\n\r\n            if (j+1 < copyGrid[i].length && copyGrid[i][j+1].alive){\r\n                liveNeighbours += 1\r\n            }\r\n\r\n            // bottom\r\n            if (i + 1 < copyGrid.length && j-1 >= 0 && copyGrid[i+1][j-1].alive){\r\n                liveNeighbours += 1\r\n            }\r\n            if (i + 1 < copyGrid.length && copyGrid[i+1][j].alive){\r\n                liveNeighbours += 1\r\n            }\r\n            if (i + 1 < copyGrid.length && j+1 < copyGrid[i].length && copyGrid[i+1][j+1].alive){\r\n                liveNeighbours += 1\r\n            }\r\n\r\n            // current cell alive\r\n            if (copyGrid[i][j].alive) {\r\n                \r\n                // two or three live neighbours lives on to the next generation.\r\n                // fewer than two live neighbours dies, as if by underpopulation.\r\n                // more than three live neighbours dies, as if by overpopulation.\r\n                if (liveNeighbours === 2 || liveNeighbours === 3) {\r\n                    // cell keeps living\r\n                    col.alive = true\r\n                }\r\n\r\n            } else {\r\n                // Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\r\n                if (liveNeighbours === 3){\r\n                    col.alive = true\r\n                }\r\n            }\r\n\r\n        \r\n\r\n            row.push(col)\r\n\r\n        }\r\n\r\n        newGrid.push(row)\r\n\r\n    }\r\n\r\n    return newGrid\r\n}\r\n\r\n\r\nexport { gridCreation,nextGeneration }","import React, { useState, useEffect } from 'react';\nimport GameScreen from './components/GameScreen';\nimport Buttons from './components/Buttons';\nimport Rules from './components/Rules';\n\nimport{ gridCreation, nextGeneration } from './util/gridCreation';\n\nimport './App.css';\n\n\n\nfunction App() {\n\n  const [gridSize ,setGridSize] = useState(25);\n  const [grid, setGrid] = useState([[]]);\n  const [play, setPlay] = useState(false);\n  const [generations, setGeneration] = useState(0)\n  const [speed, setSpeed] = useState(200)\n\n  \n  useEffect(()=>{\n    \n    setGrid(gridCreation(gridSize))\n\n  },[gridSize])\n\n  useEffect(()=> {\n\n    play && setTimeout(() => {\n      setGeneration(generations + 1)\n      setGrid(nextGeneration(grid))\n    }, speed);\n\n  },[grid,play])\n\n\n  const changeCell = ({x,y}) => {\n\n    if (!play){\n      const newState = [...grid];\n      newState[y][x].alive = !newState[y][x].alive;\n      setGrid(newState);\n    }\n\n\n  }\n\n\n  const updateGrid = (val) => {\n    setGridSize(val)\n  }\n\n  const clearGrid = () => {\n    setPlay(false)\n\n    setTimeout(() => {\n      setGrid(gridCreation(gridSize))\n      \n      setGeneration(0)\n\n      setSpeed(200)\n    }, speed);\n\n  }\n\n  const nextGen = () => {\n    setGeneration(generations + 1)\n    setGrid(nextGeneration(grid))\n  }\n\n  return (\n    \n    <div className=\"App\">\n      <header className=\"header\">\n        <h1>Game of Life</h1>\n      </header>\n\n      <main className=\"content\">\n\n        <Buttons speed={speed} setSpeed={setSpeed} generations={generations} setPlay={setPlay} play={play} gridSize={gridSize} updateGrid={updateGrid} clearGrid={clearGrid} nextGen={nextGen}/>\n\n        <GameScreen grid={grid} changeCell={changeCell}/>\n\n        <Rules/>\n\n      </main>\n\n      <footer>\n        <small>Created by <a href='https://adrianbparra.com/' target=\"_blank\" rel=\"noopener noreferrer\">adrianbparra.com</a> </small>\n      </footer>\n    </div>\n    \n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n\n"],"sourceRoot":""}